// NestJS framework imports for creating REST API controllers
import {
  Controller,
  Get,
  Post,
  Body,
  Query,
  HttpException,
  HttpStatus,
  ValidationPipe,
  UsePipes,
  Res,
  Headers,
} from '@nestjs/common';

// Swagger/OpenAPI imports for API documentation
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBody,
  ApiQuery,
} from '@nestjs/swagger';

// Express Response type for streaming endpoints
import type { Response } from 'express';

// Import the main business logic service
import { PlacesService } from './places.service';

// Import all Data Transfer Objects (DTOs) for request/response validation
import {
  ChatDto,
  SearchQueryDto,
  ChatResponseDto,
  SearchResponseDto,
  HealthResponseDto,
  ExamplesResponseDto,
  UnifiedChatDto,
  UnifiedChatResponseDto,
} from './dto';

// Swagger tag for grouping all endpoints under "Places" in API docs
@ApiTags('Places')

// Define the base route for all endpoints in this controller
@Controller('api/places')

/**
 * PlacesController - Main REST API controller for the Foursquare Places application
 * 
 * This controller provides multiple endpoints for location intelligence:
 * 1. /chat - Legacy non-streaming chat with AI agents
 * 2. /chat/stream - Streaming chat using Server-Sent Events (SSE)
 * 3. /search - Parameterized place search
 * 4. /location - Get location suggestions
 * 5. /health - Health check endpoint
 * 6. /examples - Usage examples for the API
 * 7. /chat/unified - Intelligent routing endpoint (NEW)
 * 
 * The controller acts as the entry point for all HTTP requests and delegates
 * business logic to the PlacesService.
 */
export class PlacesController {
  /**
   * Constructor - Injects the PlacesService for handling business logic
   * @param placesService - Service containing all business logic for places operations
   */
  constructor(private readonly placesService: PlacesService) {}

  /**
   * POST /api/places/chat - Legacy Chat Endpoint (Non-streaming)
   * 
   * This endpoint accepts natural language queries and returns complete responses.
   * It uses the OrchestratorAgent to process queries and return structured data.
   * 
   * Flow:
   * 1. Receive user message and optional sessionId
   * 2. Pass to PlacesService.chatWithAgent()
   * 3. Service routes to appropriate Mastra agent
   * 4. Agent processes query using external APIs
   * 5. Return complete response with success status
   * 
   * @param chatDto - Contains message and optional sessionId
   * @returns ChatResponseDto with success flag, response text, and timestamp
   */
  @Post('chat')
  @ApiOperation({
    summary: 'Chat with Location Intelligence Agent',
    description:
      'Send a natural language message to the location intelligence agent for places search and information',
  })
  @ApiBody({ type: ChatDto })
  @ApiResponse({
    status: 200,
    description: 'Successfully processed the chat message',
    type: ChatResponseDto,
  })
  @ApiResponse({
    status: 400,
    description: 'Bad request - Invalid input',
  })
  @ApiResponse({
    status: 500,
    description: 'Internal server error',
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async chatWithAgent(@Body() chatDto: ChatDto): Promise<ChatResponseDto> {
    try {
      // Extract message and sessionId from validated request body
      const { message, sessionId } = chatDto;

      // Delegate to service layer for business logic processing
      const response = await this.placesService.chatWithAgent(
        message,
        sessionId,
      );

      // Return standardized success response
      return {
        success: true,
        response,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      // Convert any errors to HTTP exceptions with proper status codes
      throw new HttpException(
        error instanceof Error ? error.message : 'Internal server error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * POST /api/places/chat/stream - Streaming Chat Endpoint
   * 
   * This endpoint provides real-time streaming responses using Server-Sent Events (SSE).
   * Ideal for long-running queries where users want to see progress in real-time.
   * 
   * Flow:
   * 1. Set SSE headers for streaming response
   * 2. Send initial 'start' event with metadata
   * 3. Stream content chunks as they're generated by the agent
   * 4. Send 'done' event when complete, or 'error' event if failed
   * 5. Close the connection
   * 
   * SSE Event Types:
   * - 'start': Initial metadata (sessionId, timestamp)
   * - 'content': Streaming response chunks
   * - 'done': Completion signal
   * - 'error': Error occurred during processing
   * 
   * @param chatDto - Contains message and optional sessionId
   * @param res - Express Response object for streaming
   */
  @Post('chat/stream')
  @ApiOperation({
    summary: 'Chat with Location Intelligence Agent (Streaming)',
    description:
      'Send a natural language message to the location intelligence agent with streaming response using Server-Sent Events',
  })
  @ApiBody({ type: ChatDto })
  @ApiResponse({
    status: 200,
    description: 'Successfully started streaming chat response',
    content: {
      'text/plain': {
        schema: {
          type: 'string',
          description: 'Server-Sent Events stream',
        },
      },
    },
  })
  @ApiResponse({
    status: 400,
    description: 'Bad request - Invalid input',
  })
  @ApiResponse({
    status: 500,
    description: 'Internal server error',
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async chatWithAgentStream(
    @Body() chatDto: ChatDto,
    @Res() res: Response,
  ): Promise<void> {
    try {
      const { message, sessionId } = chatDto;

      // Configure Server-Sent Events headers for streaming
      res.writeHead(200, {
        'Content-Type': 'text/plain; charset=utf-8',
        'Cache-Control': 'no-cache', // Prevent caching of stream
        Connection: 'keep-alive', // Keep connection open
        'Access-Control-Allow-Origin': '*', // CORS for web clients
        'Access-Control-Allow-Headers': 'Cache-Control',
      });

      // Send initial metadata to client
      res.write(
        `data: ${JSON.stringify({
          type: 'start',
          timestamp: new Date().toISOString(),
          sessionId,
        })}\n\n`,
      );

      try {
        // Stream response chunks as they're generated
        for await (const chunk of this.placesService.chatWithAgentStream(
          message,
          sessionId,
        )) {
          res.write(
            `data: ${JSON.stringify({
              type: 'content',
              content: chunk,
              timestamp: new Date().toISOString(),
            })}\n\n`,
          );
        }

        // Signal successful completion
        res.write(
          `data: ${JSON.stringify({
            type: 'done',
            timestamp: new Date().toISOString(),
          })}\n\n`,
        );
      } catch (streamError) {
        // Send error event if streaming fails
        res.write(
          `data: ${JSON.stringify({
            type: 'error',
            error:
              streamError instanceof Error
                ? streamError.message
                : 'Stream error',
            timestamp: new Date().toISOString(),
          })}\n\n`,
        );
      }

      // Close the SSE connection
      res.end();
    } catch (error) {
      // Handle errors that occur before streaming starts
      if (!res.headersSent) {
        throw new HttpException(
          error instanceof Error ? error.message : 'Internal server error',
          HttpStatus.INTERNAL_SERVER_ERROR,
        );
      }
    }
  }

  @Get('search')
  @ApiOperation({
    summary: 'Search Places',
    description:
      'Search for places using query parameters. Converts to natural language for the agent.',
  })
  @ApiQuery({
    name: 'query',
    description: 'Search query for places',
    example: 'restaurants',
  })
  @ApiQuery({
    name: 'lat',
    description: 'Latitude coordinate',
    required: false,
    example: '40.7128',
  })
  @ApiQuery({
    name: 'lon',
    description: 'Longitude coordinate',
    required: false,
    example: '-74.0060',
  })
  @ApiQuery({
    name: 'limit',
    description: 'Maximum number of results',
    required: false,
    example: '10',
  })
  @ApiQuery({
    name: 'radius',
    description: 'Search radius in meters',
    required: false,
    example: '1000',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully searched for places',
    type: SearchResponseDto,
  })
  @ApiResponse({
    status: 400,
    description: 'Bad request - Invalid query parameters',
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async searchPlaces(
    @Query() queryDto: SearchQueryDto,
  ): Promise<SearchResponseDto> {
    try {
      const { query, lat, lon, limit, radius } = queryDto;

      const result = await this.placesService.searchPlaces(
        query,
        lat,
        lon,
        limit,
        radius,
      );

      return {
        success: true,
        response: result.response,
        originalQuery: query,
        searchMessage: result.searchMessage,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      throw new HttpException(
        error instanceof Error ? error.message : 'Failed to search places',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  @Get('location')
  @ApiOperation({
    summary: 'Get Location Suggestion',
    description: 'Ask the agent to help determine current location',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully processed location request',
    type: ChatResponseDto,
  })
  @ApiResponse({
    status: 500,
    description: 'Internal server error',
  })
  async getLocationSuggestion(): Promise<ChatResponseDto> {
    try {
      const response = await this.placesService.getLocationSuggestion();

      return {
        success: true,
        response,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      throw new HttpException(
        error instanceof Error ? error.message : 'Failed to get location',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  @Get('health')
  @ApiOperation({
    summary: 'Health Check',
    description: 'Check the health status of the Places API',
  })
  @ApiResponse({
    status: 200,
    description: 'Service is healthy',
    type: HealthResponseDto,
  })
  healthCheck(): HealthResponseDto {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
    };
  }

  @Get('examples')
  @ApiOperation({
    summary: 'Get Usage Examples',
    description:
      'Get examples of what you can ask the location intelligence agent',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully retrieved examples',
    type: ExamplesResponseDto,
  })
  getExamples(): ExamplesResponseDto {
    return {
      success: true,
      examples: [
        {
          category: 'Search',
          examples: [
            'Find restaurants near me',
            'Search for coffee shops in New York',
            'Find gas stations within 5 km of coordinates 40.7128, -74.0060',
            'Look for hotels near Times Square',
          ],
        },
        {
          category: 'Details',
          examples: [
            'Tell me more about Starbucks',
            'Get details about that restaurant',
            'Show me information about the first result',
          ],
        },
        {
          category: 'Location',
          examples: [
            'Where am I?',
            'What is my current location?',
            'Find my location',
          ],
        },
        {
          category: 'Photos',
          examples: [
            'Show me photos of that place',
            'Get images for this restaurant',
          ],
        },
      ],
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * POST /api/places/chat/unified - Intelligent Unified Chat Endpoint
   * 
   * This is the most advanced endpoint that intelligently analyzes user queries
   * and automatically determines the best response format:
   * 
   * Response Types:
   * - 'text': Regular conversational responses
   * - 'geojson': Map data for location-based queries
   * - 'analysis': Statistical/analytical data
   * 
   * Intelligence Flow:
   * 1. Analyze user query for intent (map, analysis, or general)
   * 2. Route to appropriate service:
   *    - MapDataService for location/map queries → GeoJSON
   *    - OrchestratorService for analysis queries → structured data
   *    - Default to text responses for general queries
   * 3. Return response with metadata about processing
   * 
   * This endpoint replaces the need for multiple specialized endpoints
   * by providing intelligent routing based on query content.
   * 
   * @param unifiedChatDto - Contains message, sessionId, and response preference
   * @returns UnifiedChatResponseDto with intelligent response type and metadata
   */
  @Post('chat/unified')
  @ApiOperation({
    summary:
      'Unified Chat Endpoint - Intelligently Routes to Appropriate Services',
    description:
      'Single endpoint that analyzes user queries and automatically returns text, GeoJSON, or analysis data based on content. This is the ultimate chatbot endpoint that handles all query types intelligently.',
  })
  @ApiBody({ type: UnifiedChatDto })
  @ApiResponse({
    status: 200,
    description: 'Successfully processed the unified chat request',
    type: UnifiedChatResponseDto,
  })
  @ApiResponse({
    status: 400,
    description: 'Bad request - Invalid input',
  })
  @ApiResponse({
    status: 500,
    description: 'Internal server error',
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async processUnifiedChat(
    @Body() unifiedChatDto: UnifiedChatDto,
  ): Promise<UnifiedChatResponseDto> {
    try {
      // Delegate to service for intelligent query processing and routing
      return await this.placesService.processUnifiedChat(unifiedChatDto);
    } catch (error) {
      throw new HttpException(
        error instanceof Error ? error.message : 'Internal server error',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
